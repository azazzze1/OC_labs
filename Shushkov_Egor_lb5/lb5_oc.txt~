1. Ненадёжные сигналы. 
    Необходимо написать программу, которая будет изменять диспозицию
    сигналов, а именно нужно:
    -Установить обработчик пользовательских сигналов SIGUSR1(2). 
    -Установить реакцию по умолчанию на сигнал SIGINT.
    -Игнорировать SIGCHLD.
    -Породить процесс-копию и уйти в ожидание сигналов. 
Обработчик должен восстановить диспозицию и оповестить на экран о полученном
сигнале и отправить процессу-потомку ppid, чтобы тот отправил родителю игнал
SIGUSR1.

unreliable_signals.c:

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

static void handler(int sig){
    if(sig == SIGUSR1){
        printf("Получен сигнал SIGUSR1\n");
    }else{ 
        printf("Получен сигнал SIGUSR2\n");
    }

    printf("Родитель = %d\n", getppid());
    signal(sig, SIG_DFL);
}

int main(){
    printf("\nРодитель запустился: pid = %d, ppid = %d\n", getpid(), getppid()); 
    signal(SIGUSR1, handler);
    signal(SIGUSR2, handler);
    signal(SIGINT, SIG_DFL);
    signal(SIGCHLD, SIG_IGN);

    int fork_child = fork(); 
    if(fork_child == 0){
        printf("\nПроцесс-ребёнок запустился: pid = %d, ppid = %d\n", getpid(), getppid());

        if(kill(getppid(), SIGUSR1) != 0){
            printf("Ошибка во время отправки SIGUSR1\n"); 
            exit(-1); 
        }
        printf("Успешно отправлен сигнал SIGUSRT1\n"); 

        return 0;
    } 

    wait(NULL);

    while(1){
        pause(); 
    }
}

Выполнение программы:
Родитель запустился: pid = 777333, ppid = 410153

Процесс-ребёнок запустился: pid = 777334, ppid = 777333
Успешно отправлен сигнал SIGUSR1
Родитель = 410153

На этом этапе программа переходит в ожидание сигнала. Отправим три сигнала:
kill -SIGUSR2 777593
kill -SIGCHLD 777593
kill -SIGINT 777593

Родитель запустился: pid = 777593, ppid = 410153

Процесс-ребёнок запустился: pid = 777594, ppid = 777593
Успешно отправлен сигнал SIGUSRT1
Получен сигнал SIGUSR1
Родитель = 410153
Получен сигнал SIGUSR2
Родитель = 410153


Как и ожидалось: SIGUSR2 был зафиксирован, SIGCHLD был проигнорирован, а
SIGINT привёл к завершению программы. Теперь отправим два сигнала SIGUSRT2:

Родитель запустился: pid = 784072, ppid = 489201

Процесс-ребёнок запустился: pid = 784073, ppid = 784072
Успешно отправлен сигнал SIGUSRT1
Получен сигнал SIGUSR1
Родитель = 489201
Получен сигнал SIGUSR2
Родитель = 489201
Определяемый пользователем сигнал 2

Как мы видим, второй сигнал завершил процесс, потому что обработчик прерываний после
первого сигнала восстанавливают диспозицию сигналов.

1.1. Напишем две программы:

father1_1.c: 

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

static void sigsegv_handler(int sig); 

static void sigtrap_handler(int sig){
    signal(SIGTRAP, sigtrap_handler); 
    printf("Сигнал SIGTRAP обработан в родителе\n"); 
}

int main(){
    int child_pid;
    int pid = getpid();
    printf("Процесс-родитель запустился: pid = %d\n", pid);

    signal(SIGCHLD, SIG_DFL);
    signal(SIGTRAP, sigtrap_handler);
    signal(SIGSEGV, sigsegv_handler);

    if((child_pid = fork()) == 0){
        execl("son1_1", "son1_1", NULL);
    }

    while(1){
        sleep(2);
    }
}

static void sigsegv_handler(int sig){
    signal(SIGSEGV, sigsegv_handler);
    printf("Сигнал SIGSEGV получен\n"); 
}

son1_1.c:
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>


int main(){
    int child_pid = getpid(); 
    int ppid = getppid();
    printf("Процесс-ребёнок запустился: pid = %d\n", child_pid);
    
    kill(ppid, SIGTRAP); 

    printf("Сигнал SIGTRAP был обработан в процессе-ребёнке\n"); 

    while(1){
        sleep(2);
    }
}


Выполнение программы, отправили два сигнала - один на родителя, другой на сына:
kill -SIGTRAP 798502
kill -SIGTRAP 798503

роцесс-родитель запустился: pid = 798502
Процесс-ребёнок запустился: pid = 798503
Сигнал SIGTRAP был обработан в процессе-ребёнке
Сигнал SIGTRAP обработан в родителе
Сигнал SIGTRAP обработан в родителе

Таким образом, можем понять, что при создании процесса с помощью fork()
обработчики сигналов наследуются. 

2.1. Надёждные сигналы. 
Напишем программу, которая продемонстрирует возможность отложенной обработки
сигнала.
Для этого воспользуемся указателем на структуру sigaction. Блокировка
реализуем через "засыпание" процесса на одну минуту из обработчика
пользовательских сигналов. В основной программе установим диспозицию этих
сигналов.

reilable_signal.c:

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

void (*user_signal(int sig, void (*hndler)(int))) (int){
    struct sigaction act, prev_act;
    act.sa_handler = hndler; 
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGINT);
    act.sa_flags = 0; 
    
    if(sigaction(sig, &act, 0) < 0){
        return SIG_ERR;
    }
    return act.sa_handler; 
}

void SIGUSR1_handler(int sig){
    if(sig != SIGUSR1){
        printf("Поймане не то сигнал\n");
        return;
    }
    printf("SIGUSR1 пойман\n"); 
    sleep(60); 
}

int main(){
    user_signal(SIGUSR1, SIGUSR1_handler); 
    while(1){
        pause(); 
    }
}

Выполнение программы: 
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ ./rel_sig &
[3] 826199
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ kill -SIGUSR1 826199
SIGUSR1 пойман
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ kill -SIGINT 826199
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ jobs
[3]   Запущен          ./rel_sig &
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ jobs
[3]   Прерывание    ./rel_sig

Программа была запущена в фоновом режиме для того чтобы отправить сигналы
прямо с этого терминала. Первый сигнал принят корректно, а второй был выполнен
не сразу. Так как сигнал надёжный, то SIGINT был поставлен в очередь и ждал
выполнения обработчика. Сигнал был записан в маску PENDING и ждал своего
момента. 

2.2. Напишем программу, где обработчик отправлял из себя другой сигнал.
Пускай SIGUSR1 будет отправлять SIGINT: 

nested_signal.c: 

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

void (*user_signal(int sig, void (*hndler)(int))) (int){
    struct sigaction act, prev_act;
    act.sa_handler = hndler; 
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGINT);
    act.sa_flags = 0; 
    
    if(sigaction(sig, &act, 0) < 0){
        return SIG_ERR;
    }
    return act.sa_handler; 
}

void SIGUSR1_handler(int sig){
    if(sig != SIGUSR1){
        printf("Поймане не то сигнал\n");
        return;
    }
    printf("SIGUSR1 пойман. Отсылаем SIGINT\n"); 
    kill(getpid(), SIGINT); 
    sleep(10); 
}

int main(){
    user_signal(SIGUSR1, SIGUSR1_handler); 
    while(1){
        pause(); 
    }
}

Выполнение программы:
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ ./nes_sig &
[3] 836524
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ kill -SIGUSR1 836524
azazzzel@azazzzel-HP-Laptop-15s-fq2xxx:~/lb5$ SIGUSR1 пойман. Отсылаем SIGINT
jobs
[3]   Запущен       ./nes_sig
jobs
[3]   Прерывание    ./nes_sig

Аналогично прошлому заданию, обработчик ждёт окончание первого обработчика,
чтобы выполнить вложенный. 

Таким образом, можно выделить следующие плюс надёжных сигналов:
    -Диспозиция устанавливается только один раз, не надо делать это в
    обработчике.
    -При установке диспозиции можно указать, какие сигналы будут
    блокрироваться на фремя обработки конкретного сигнала, что даёт гибкую
    настройку.

3.1. Проведём эксперимент, позволяющий определить возможность орагнизации
очереди для различных типов сигналов, обычных и реального времени:

signal_queue.c:

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

void handle_signal(int sig, siginfo_t *info, void* context){
    printf("Отправлен сигнал %d со значением %d\n", sig, info->si_value.sival_int);        
}


int main(){
    struct sigaction act; 
    union sigval value;
    
    act.sa_sigaction = handle_signal;
    act.sa_flags = SA_SIGINFO;
    sigemptyset(&act.sa_mask);
    
    for(int i = SIGRTMIN; i <= SIGRTMAX; ++i){
        sigaddset(&act.sa_mask, i); 
    }

    for(int i = 1; i <= 4; ++i){
        sigaction(SIGINT + i, &act, NULL);
        sigaction(SIGRTMIN + i, &act, NULL); 
    }

    /* 4 - количество сигналов */
    for(int i = 1; i <= 4; ++i){
        value.sival_int = i;
        printf("Отправляем сигнал %d со значением %d\n", SIGINT + i, value.sival_int); 
        
        if(sigqueue(getpid(), SIGINT + i, value) != 0){
            perror("sigqueue");
            exit(EXIT_FAILURE); 
        }
        printf("Отправляем сигнал %d со значением %d\n", SIGRTMIN + i, value.sival_int);

        if(sigqueue(getpid(), SIGRTMIN + i, value) != 0){
            perror("sigqueue");
            exit(EXIT_FAILURE); 
        }
    }

    sleep(1);

    return 0;
}

Выполнение программы:
Отправляем сигнал 3 со значением 1
Отправлен сигнал 3 со значением 1
Отправляем сигнал 35 со значением 1
Отправлен сигнал 35 со значением 1
Отправляем сигнал 4 со значением 2
Отправлен сигнал 4 со значением 2
Отправляем сигнал 36 со значением 2
Отправлен сигнал 36 со значением 2
Отправляем сигнал 5 со значением 3
Отправлен сигнал 5 со значением 3
Отправляем сигнал 37 со значением 3
Отправлен сигнал 37 со значением 3
Отправляем сигнал 6 со значением 4
Отправлен сигнал 6 со значением 4
Отправляем сигнал 38 со значением 4
Отправлен сигнал 38 со значением 4

В данном эксперименте мы отправляем 4 обычных сигнала и 4 сигнала реального
времени на один процесс с разными значениями. 
Исходя из резултатов программы, можно сказать, что сигналы разных типов могут
ствиться в очередь. То есть обрабатываются они упорядоченно. Кроме того,
сигналы реального времени с одинаковыми приоритетами обрабатываются в FIFO,
как и обычные сигналы.

3.2 Подтвердим, что у сигналов реального времени есть приоритеты:

check_real_time_signals.c:

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sched.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

void handle_real_time_signal(int sig, siginfo_t *info, void* context){
    printf("Обрабатывается сигнал реального времени %d", sig);
    usleep(1000000);     
}

void handle_normal_signal(int sig){
    printf("Обрабатывается обычный сигнал %d\n", sig); 
}


int main(){
    freopen("log.txt", "w", stdout); 

    struct sigaction act; 
    union sigval value;
    
    act.sa_sigaction = handle_real_time_signal;
    act.sa_flags = SA_SIGINFO;
    sigemptyset(&act.sa_mask);
    
    for(int i = SIGRTMIN; i <= SIGRTMAX; ++i){
        sigaction(i, &act, NULL);
    }

    for(int i = 1; i <= 5; ++i){
        signal(i, handle_normal_signal); 
    }

    printf("Отправляем сигнал\n"); 

    /* 5 - количество сигналов */
    for(int i = 1; i <= 5; ++i){
        printf("Отправляем нормальный сигнал %d\n", i); 
        kill(getpid(), i);    
    }
    for(int i = SIGRTMIN; i <= SIGRTMAX; ++i){
        printf("Отправляем сигнал реального времени %d\n", i); 
        kill(getpid(), i); 
    }

    printf("Сигналы отправлены. Обработка...\n");

    sleep(5);

    return 0;
}

Файл log.txt после выполнения программы:
Отправляем сигнал
Отправляем нормальный сигнал 1
Обрабатывается обычный сигнал 1
Отправляем нормальный сигнал 2
Обрабатывается обычный сигнал 2
Отправляем нормальный сигнал 3
Обрабатывается обычный сигнал 3
Отправляем нормальный сигнал 4
Обрабатывается обычный сигнал 4
Отправляем нормальный сигнал 5
Обрабатывается обычный сигнал 5
Отправляем сигнал реального времени 34
Обрабатывается сигнал реального времени 34Отправляем сигнал реального времени 35
Обрабатывается сигнал реального времени 35Отправляем сигнал реального времени 36
Обрабатывается сигнал реального времени 36Отправляем сигнал реального времени 37
Обрабатывается сигнал реального времени 37Отправляем сигнал реального времени 38
Обрабатывается сигнал реального времени 38Отправляем сигнал реального времени 39
Обрабатывается сигнал реального времени 39Обрабатывается обычный сигнал 2
Отправляем сигнал реального времени 40
Обрабатывается сигнал реального времени 40Отправляем сигнал реального времени 41
Обрабатывается сигнал реального времени 41Отправляем сигнал реального времени 42
Обрабатывается сигнал реального времени 42Отправляем сигнал реального времени 43
Обрабатывается сигнал реального времени 43Отправляем сигнал реального времени 44
Обрабатывается сигнал реального времени 44Отправляем сигнал реального времени 45
Обрабатывается сигнал реального времени 45Отправляем сигнал реального времени 46
Обрабатывается сигнал реального времени 46Отправляем сигнал реального времени 47
Обрабатывается сигнал реального времени 47Отправляем сигнал реального времени 48
Обрабатывается сигнал реального времени 48Отправляем сигнал реального времени 49
Обрабатывается сигнал реального времени 49Отправляем сигнал реального времени 50
Обрабатывается сигнал реального времени 50Отправляем сигнал реального времени 51
Обрабатывается сигнал реального времени 51Отправляем сигнал реального времени 52
Обрабатывается сигнал реального времени 52Отправляем сигнал реального времени 53
Обрабатывается сигнал реального времени 53Отправляем сигнал реального времени 54
Обрабатывается сигнал реального времени 54Отправляем сигнал реального времени 55
Обрабатывается сигнал реального времени 55Отправляем сигнал реального времени 56
Обрабатывается сигнал реального времени 56Отправляем сигнал реального времени 57
Обрабатывается сигнал реального времени 57Отправляем сигнал реального времени 58
Обрабатывается сигнал реального времени 58Отправляем сигнал реального времени 59
Обрабатывается сигнал реального времени 59Отправляем сигнал реального времени 60
Обрабатывается сигнал реального времени 60Отправляем сигнал реального времени 61
Обрабатывается сигнал реального времени 61Отправляем сигнал реального времени 62
Обрабатывается сигнал реального времени 62Отправляем сигнал реального времени 63
Обрабатывается сигнал реального времени 63Отправляем сигнал реального времени 64
Обрабатывается сигнал реального времени 64Сигналы отправлены. Обработка...

Это доказывает, что сигналы реального времени имеют приоритет выше обычных,
они обрабатываются в первую очередь. 


4.1 Неименованные каналы.
Организуем программу (файл pipe.c) так, чтобы процесс-родитель
создавал неименованный канал, создавал потомка, закрывал канал на запись и
записывал в произвольный текстовый файл считываемую из канала
информацию. В функции процесса-потомка будет входить считывание данных
из файла и запись их в канал. (Функционирование осуществляется) 

pipe.c: 
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define DEF_F_R "from.txt"
#define DEF_F_W "to.txt"

int main(int argc, char** argv) {
    char fileToRead[32],
    fileToWrite[32];
    if(argc < 3 ){
        printf("Используем стандартные имена файлов '%s','%s'\n",DEF_F_R,DEF_F_W);
        strcpy(fileToRead,DEF_F_R);
        strcpy(fileToWrite,DEF_F_W);
    }
    else {
        strcpy(fileToRead,argv[1]);
        strcpy(fileToWrite,argv[2]);
    }
    
    int filedes[2];
    if(pipe(filedes) < 0) {
        printf("Родитель: не может создать канал\n");
        exit(1);
    }
    printf("Канал успешно создан\n");
    if(fork() == 0) {
// процесс сын
// закрывает пайп для чтения
        close(filedes[0]);
        FILE* f = fopen(fileToRead,"r");
        if (!f){
            printf("Сын: не может открыть файл%s\n",fileToRead);
            exit(1);
        }
        char buf[100];
        int res;
        while(!feof(f)) {
            // читаем данные из файла
            res = fread(buf,sizeof(char),100,f);
            write(filedes[1],buf,res); // пишем их в пайп
        }
        close(f);
        close(filedes[1]);
         return 0;
    }
// процесс отец
// закрывает пайп для записи
     close(filedes[1]);
     FILE *f = fopen(fileToWrite,"w");
    if (!f) {
    printf("Родитель: не может открыть файл %s\n",fileToWrite);
    exit(1);
    }
    
    char buf[100];
    int res;
    while(1) {
        bzero(buf,100);
        res = read(filedes[0],buf,100);
        if(!res)
            break;
        printf("Считывание из канал: %s\n",buf);
        fwrite(buf,sizeof(char),res,f);
    }
    fclose(f);
    close(filedes[0]);
    return 0;
}

Выполнение программы:
